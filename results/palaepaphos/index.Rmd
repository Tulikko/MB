---
title: "Palaepaphos mudbrick analysis"
author: "Uine Kailam√§ki"
output:
  html_document:
    theme: cosmo
    fig_caption: true
    fig_width: 12
    fig_height: 8 
    
---


### pXRF

Introduction

```{r}
# Libraries
library(dplyr); 
library(GGally); 
library(corrplot); 
library(tidyr); 
library(openxlsx); 
library(cluster); 
library(ggplot2); 
library(ggfortify); 
library(pca3d);
library(ggdendro) # dendrograms together with ggplot
library(dendextend) # dendrograms - change parameters
library(tidyverse) # rectangles around HClust

# Read data
pxrf <- read.xlsx("data/pxrf_PP.xlsx", sep=";")

# Remove any rows containing words 'ERROR' or 'TEST'
pxrf <- filter(pxrf, !grepl('TEST', Sample))
pxrf <- filter(pxrf, !grepl('ERROR', Sample))

# Turn any "LOD":s and missing values to "NA":s to allow scaling
values <- c("MgO", "Al2O3", "SiO2", 
            "S", "Cl", "K2O", "CaO", "Ti", "V", "Cr", 
            "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "As", 
            "Se", "Rb", "Sr", "Y", "Zr", "Nb", "Mo", 
            "Rh", "Pd", "Ag", "Cd", "Sn", "Sb", 
            "La", "Ce", "Hf", "Ta", "W", "Pt", "Au", 
            "Hg", "Tl", "Pb", "Bi", "Th", "U")

pxrf_NA <- select(pxrf, one_of(values))
pxrf_NA <- pxrf_NA %>% mutate_if(is.character,as.numeric)

# Scaling the data with standard z-score method
scaled_pxrf <- as.data.frame(scale(pxrf_NA))

# Average data by "Sample", "Area" and "Type" columns from the original dataset
average_pxrf <- aggregate(scaled_pxrf, by = list(pxrf$Sample, pxrf$Area, pxrf$Type), FUN = mean)

# Assign sample names as row names, and rename the other newly created columns back to "Type" and "Area" for clarity
rownames(average_pxrf) <- average_pxrf$Group.1
average_pxrf <- average_pxrf %>% select(-Group.1)
names(average_pxrf)[names(average_pxrf) == "Group.2"] <- "Area"
names(average_pxrf)[names(average_pxrf) == "Group.3"] <- "Type"

# Change "Type" and "Area" to factors
average_pxrf$Type <- factor(average_pxrf$Type)
average_pxrf$Area <- factor(average_pxrf$Area)

# Removing columns that only have NA values
all_na <- function(x) any(!is.na(x))
pxrf_all <- average_pxrf %>% select_if(all_na)

# Removing columns if they contain any NA values at all
any_na <- function(x) all(!is.na(x))
pxrf_no_na <- average_pxrf %>% select_if(any_na)

glimpse(pxrf_no_na)
glimpse(pxrf_all)


## CORRELATIONS

# Visualize correlations between elements
cor(pxrf_no_na[3:8]) %>% corrplot (type = "lower", tl.cex = 1, tl.pos="d", cl.pos="r")

# Cluster analysis

# Optimal number of clusters in K-means analysis: 2
k_max <- 8
twcss <- sapply(1:k_max, function(k){kmeans(pxrf_no_na[3:8], k)$tot.withinss})
qplot(x = 1:k_max, y = twcss, geom = 'line')

# K-means clustering in ggpairs: 2 clusters
km <-kmeans(pxrf_no_na[3:8], centers = 2)
cluster_x <- as.factor(km$cluster)
ggpairs(pxrf_no_na[3:8], mapping = aes(col = cluster_x))


# PCA
pca_n2 <- prcomp(pxrf_no_na[3:8])
summary(pca_n2)

biplot(pca_n2, choices = 1:2, cex = c(1, 1.2), col = c("grey80", "deeppink2"))


#### ONLY MUDBRICKS


# Subset n3 containing only the mudbricks
rownames(n2)
n3 <- n2[-c(46:53), ]
rownames(n3)

# Calculate the total within sum of squares to find the optimal number of clusters
k_max <- 8
twcss <- sapply(1:k_max, function(k){kmeans(n3, k)$tot.withinss})
qplot(x = 1:k_max, y = twcss, geom = 'line')

# PCA
pca_n3 <- prcomp(n3)
summary(pca_n3)

biplot(pca_n3, choices = 1:2, cex = c(1, 1.2), col = c("grey80", "deeppink2"))

#Visualize PC:s

plot(pca_n3, type="lines")

# 3D PCA plots



# HCA (only mudbricks)
dend <- 
    n3 %>%                              # data
    dist %>%                            # calculate a distance matrix
    hclust(method = "ward.D2") %>%      # hierarchical clustering 
    as.dendrogram %>%                   # turn the object into a dendrogram
    set("branches_k_color", k=3) %>% 
    set("branches_lwd", 1.2) %>%
    set("labels_col", c("red", "black", "blue"), k=3) %>%    
    set("labels_cex", 1) %>% 
    set("leaves_pch", NA) 
# plot the dend in usual "base" plotting engine:
plot(dend)



###### NEW PLOTS WITH CLASS INFO #######

# PCA
pca_01 <- prcomp(n1[3:8])
summary(pca_01)

n4 <- n1 %>% select(-Ni)
pca_02 <- prcomp(n4[3:7])
summary(pca_02)

# PCA

biplot(pca_01, choices = 1:2, cex = c(1, 1.2), col = c("grey80", "deeppink2"), main = "PCA All elements")
autoplot(pca_01, data=n1, colour='Area', shape = FALSE, label = TRUE,  main = "PCA All elements")

biplot(pca_02, choices = 1:2, cex = c(1, 1.2), col = c("grey80", "deeppink2"), main = "No nickel")
autoplot(pca_02, data=n4, colour='Area', shape = FALSE, label = TRUE,  main = "No nickel")


# only new MB samples

n5 <- n1 %>% select(-Ni)
n5 <- n5[-c(12:53), ]
pca_03 <- prcomp(n5[3:7])
summary(pca_03)


# HCA
dend <- 
    n5 %>%                              # data
    dist %>%                            # calculate a distance matrix
    hclust(method = "ward.D2") %>%      # hierarchical clustering 
    as.dendrogram %>%                   # turn the object into a dendrogram
    set("branches_k_color", k=3) %>% 
    set("branches_lwd", 1.2) %>%
    set("labels_col", c("red", "black", "blue"), k=3) %>%    
    set("labels_cex", 1) %>% 
    set("leaves_pch", NA) 
# plot the dend in usual "base" plotting engine:
plot(dend)

biplot(pca_03, choices = 1:2, cex = c(1, 1.2), col = c("grey80", "deeppink2"), main = "Only new MB samples")

autoplot(pca_03, data=n5, colour='Area', shape = FALSE, label = TRUE,  main = "Only new MB samples")


# Wards method (HCA) method 2: 
HCA.ward5 <- hclust(dist(n5, method="euclid"), method="ward.D2")
plot(HCA.ward5, main="Ward's method")
rect.hclust(HCA.ward5, k=3)


```

### Particle size

Introduction

```{r}
## Particle size
# Read and filter data
particle <- read.xlsx("data/grain_PP.xlsx", sep=";")

# Remove automatically created averages in order to include results from multiple runs for the same sample
particle <- particle %>% 
  filter(!grepl('Average', Sample)) %>% 
  filter(!grepl('test', Sample))

# Average by sample name
particle <- aggregate(particle, by=list(particle$Sample), FUN=mean)
particle <- particle %>% select(-Sample)
names(particle)[names(particle) == "Group.1"] <- "Sample"

# Saving the clean data as "PP_grain2"
## write.xlsx(particle, file="data/granulometry/PP_grain2.xlsx")

# Manually added Type and Context columns to PP_grain2 data: "PP_grain3"
grain3 <- read.xlsx("data/granulometry/PP_grain3.xlsx", sep=";")

# Samples as rownames
rownames(grain3) <- grain3$Sample 

# Scaling clay-silt-sand portions to values between 0 and 1
## Otherwise the differences in low clay percentages are lost
normalize <- function(x, na.rm=TRUE){(x-min(x, na.rm=TRUE))/(max(x, na.rm=TRUE)-min(x, na.rm=TRUE))}

grain <- as.data.frame(apply(grain3[3:5], 2, normalize))

# Ternary plots

MB_grain <- grain[c(9:19),]
MB_context <- grain3[c(9:19),]

ggtern(data=MB_grain, aes(x=Clay, y=Sand, z=Silt, color=MB_context$Locus)) +
  labs(title="Clay silt sand") +
  theme_rgbw() +
  theme_nomask() +
  geom_point(size=0) +
  geom_text(aes(label=rownames(MB_grain)), size=3)

ggtern(data=grain, aes(x=Clay, y=Sand, z=Silt, color=grain3$Context)) +
  labs(title="Clay silt sand") +
  theme_nomask() +
  geom_mask() +
  geom_point(size=2) 


```

### LOI

Introduction

```{r}

```

### Colorimetry

Introduction

```{r}

```


